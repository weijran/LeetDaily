### 题目

串联子串：对于给定的一个字符串数组，把其中的字符串按照任意顺序串起来得到的字符串。

现给一个字符串数组words和一个字符串s。找出s中所有words的串联子串出现的位置。

其中，words中的字符串是等长的。

1 <= s.length <= 10^4

1 <= words.length <= 5000

1 <= words[i].length <= 30

words[i] 和 s 由小写英文字母组成


### 关键词

用map记录字符串（哈希）
滑窗

### 方法一 暴力

map存每个单词出现的个数。枚举s串的每一个下标i作为起始点：从起始点i开始，每m位（m = words[i].length）截出一个子串，一共截出n个（n = words.length），在map中查询该子串是否为单词且还有剩余个数——若否，则i不是答案；若是，剩余个数减1。如果n个单词都通过了检查，则i是答案。每一趟i的循环都要将map复原。

复杂度为O(10000∗(5000∗30∗log5000+5000))，提交后超时。

### 方法二 滑窗

单词分割方式只有m种（m = words[i].length）。比如s="acbdefghijkl"且m=3的话：
```
abc def ghi jkl
bcd efg hij
cde fgh ijk
def ghi jkl（到这儿就会发现和第一行重复了）
```

所以无需像方法一那样枚举每一个s串的下标，而是只枚举前m个下标，作为起始位置。（能这么做得益于题目中规定“words中的字符串等长”）
对于每一种分割方式。map1存单词表中每个单词出现的个数。map2存每个单词到整数的映射。数组cnt[5000]存滑窗中每个单词出现的次数。就转化为一个简单的滑窗问题了。
