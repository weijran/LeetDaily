### 题目

推骨牌，给出最初推的几个牌的位置，问最后每个骨牌的状态。

### 关键字


### 一、O(n^2)模拟



状态有5种：`.` `L` `R` `l` `r`。L/R代表该块正在倒下（施力物体），l/r代表该块已经倒下，无法再对别的块施力。

每过1s更新一遍状态。

#### 状态转移
1. 如果某位置是`.`
   
* 左边或右边二者之一有力，那么力转移到该点
* 左右都有力，那么左右的力消失（L/R变为l/r），i位置仍是`.`

2. 其余情况该点不变

如果经过一轮后，任何位置都没有状态的改变，那么算法结束

#### 单步解释
输入:
```
R.......L.R.........
```

过程：

```
rR.....Ll.rR........
rrR...Lll.rrR.......
rrrR.Llll.rrrR......
rrrr.llll.rrrrR.....
rrrr.llll.rrrrrR....
rrrr.llll.rrrrrrR...
rrrr.llll.rrrrrrrR..
rrrr.llll.rrrrrrrrR.
rrrr.llll.rrrrrrrrrR
rrrr.llll.rrrrrrrrrR
```

输出：
```
RRRR.LLLL.RRRRRRRRRR
```


### 二、O(n)搜索法



### 三、O(n)双指针法

每个块的最终状态取决于两件事：左侧第一个施力点、右侧第一个施力点，所以首先预处理出这两个内容。

若左R右L 那么比距离，服从近的那个

若左R右R，那么R

若左L右R，直立

若左L右L，那么L

**这样的话时间复杂度O(3*n)，能否优化常数呢？可以，用双指针**

left记某段连续的`.`的左侧的推倒方向，然后遍历到右边界，记为right

若左R右L 那么对称，如`////\\\\`，或`////|\\\\`

若左R右R，那么 `///////`

若左L右R，直立 `|||||||`

若左L右L，那么`\\\\\\\\`

### 小结

这道题O(n)的算法感觉很容易想到，但一看到dp的关键词，就在O(n^2)的算法里绕不出来了。
